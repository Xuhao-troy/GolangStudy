# Golang学习——第三章 基本数据
[TOC]

1. Go的数据类型分为四大类： 基础类型、聚合类型、引用类型和接口类型。
2. 基础类型：包括数字 (number)、字符串 (string) 和 布尔型 (boolean) 。
3. 聚合类型： 包括数组 (array) 和 结构体 (struct) 。
4. 引用类型： 包含多种不同类型， 如指针 (pointer)， slice, map, 函数和通道 (channel) 。共同点在于间接指向程序变量或状态，操作所引用数据的效果会遍及该数据的所有引用。、
5. 接口类型： 见第七章

## 3.1 整数

1. Go的整数类型有: (u)int8、 (u)int16、 (u)int32、 (u)int64、 uintptr
2. rune 类型是 int32 类型的同义词， 常用于指明一个值是Unicode码点。两者可互换使用。
3. byte 类型是 uint8 类型的同义词， 强调一个值是**原始数据**，而非量值。
4. 无符号整数uintptr 大小并不明确， 但**足以完整存放指针**。
5. int 、uint 和 uintptr 都有别于其大小明确的 相似类型。 比如， 尽管int 默认大小是32位， 但是int 与 int32 仍是**不同类型**，两者**必须显式转换**。
6. **有符号整数**以**补码**表示，保留最高位作为符号位， n位数字的取值范围是 $-2^{n-1} \thicksim 2^{n-1}-1$。
7. **无符号整数**由全部位构成非负值， 范围为$ 0 \thicksim 2^n-1$。

## 3.2 浮点数

1.  Go具有两种大小的浮点数float32 和 float64 
2. math包给出了浮点值的极限。 常量math.MaxFloat32 是float32 的最大值， 约为3.4e38。 而math.MaxFloat64 约为1.8e308。 

## 3.3 复数

1. Go具备两种大小的复数 complex64 和 complex128， 二者分别由float32 和 foat64构成。
2. 内置的**complex函数**根据**给定的实部和虚部创建复数**，而内置的**real函数**和**imag函数**则分别提取**复数的实部和虚部**。
```go
   var x complex128 = complex(1, 2) // 1+2i
   var y complex128 = complex(3, 4) // 3+4i
   fmt.Println(x*y) 			    //"(-5+10i)"
   fmt.Println(real(x*y)) 			//"-5"
   fmt.Println(imag(x*y)) 			//"10"
```
3. 源码中，在浮点数或十进制整数后添加字母i，则变成虚数。

## 3.4 布尔值

1. bool值取值： true 或 false
2. 布尔值**无法隐式转换**成数值（如0或1），反之亦然。
3. 假如转换操作经常用到，就需要专门写个函数：
```go
func btoi (b bool) int {
    if b {
        return 1
    }
    return 0
}
```
## 3.5 字符串

1. 字符串是**不可变**的字节序列。

2. 内置的 len函数 返回字符串的字节数（并非文字符号的数目），下标访问操作 s[i] 则取得第i个字符， 其中$0 \leq i < len(s)$ 。

3. 字符串的第 i 个字节不一定是第 i 个字符。因为非ASCII字符的UTF-8码点需要两个或多个字节。

4. 子串生成操作`s[i:j]`产生新的字符串，取自原字符串的字节， 下标从i（含边界值）开始， 直到 j （不含边界值）结束。 结果的大小为 $j-i$ 个字节。

   **注意：**若下标越界， 或者 j 的值小于 i 的值， 则触发宕机异常。 若j等于i，则子串为空字符串。

```go
   fmt.Printf("%v", s[1:1]=="") //"true"
```

5. 加号运算符连接两字符串而生成一个新的字符串：
```go
   s := "hello, world"
   fmt.Println("goodbye" + s[5:]) //"goodbye, world"
```

## 3.6 常量
1. 常量是一种表达式， 保证在编译阶段就计算出表达式的值。

2.  常量声明可以同时指定类型和值。如果没有显式指定类型，则类型根据右边的表达式推断。

3. 若同时声明一组变量， 除了第一项外， 其他项在等号右侧的表达式均可忽略，会自动都用前一项的表达式及类型。如：

```go
   const (
       a = 1
       b
       c = 2
       d
   )
   fmt.Println(a, b, c, d) //"1 1 2 2"
```

### 3.6.1 常量生成器 iota
1. 常量声明可以使用常量生成器iota来创建一系列相关值。 

2. iota从0开始取值， 逐项加1。

   ```go
   type weekday = iota
   const (
       Sunday Weekday = iota //"0"
       Monday				//"1"
       Tuesday				//"2"
       Wednesday			//"3"
       Thursday			//"4"
       Friday				//"5"
       Saturday			//"6"
   )
   ```

   ​

3. 考虑更复杂的情况

   ```go
   const (
       A = m << (n * iota) //"m"
       B				  //"m*2^n"	
       C				  //"m*2^(2n)"
   )
   ```

   ​

### 3.6.2 无类型常量

1. Go语言中， 许多常量并不从属某一具体类型，称为无类型常量。

2. 无类型常量的优势在于： 值比基本类型的数字**精度更高**，且**算术精度**高于原生的机器精度（可认为精度至少达到256位）。

3. 从属类型待定的常量共有6种， 分为**无类型布尔、无类型整数、无类型文字符号、无类型浮点数、无类型复数和无类型字符串**。

4. 浮点型常量 `math.Pi`可用于任何需要浮点值或复数的地方

   ```Go
   var x float32 = math.Pi
   var y float64 = math.Pi
   var z complex128 = math.Pi
   ```

   如果`math.Pi`一开始就是确定类型的，则会导致精度下降。并且在上述表达式中需要转换类型。

5. 只有常量才可以无类型。若将无类型常量声明为变量，或将其赋值给类型明确的变量，则常量会被隐式转换成该变量的类型。

   ```
   var f float64 = 3 + 0i //无类型复数 -> float64
   f = 2				 // 无类型整数 -> float64
   f = 1e123			 // 无类型浮点数 -> float64
   ```

   ​

